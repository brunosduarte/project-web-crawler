describe('QueueController', () => {

    // should return queue status with pending, total and percentDone
    it('should return queue status with pending, total and percentDone when successful', async () => {
      // Arrange
      const queueSize = 5;
      const totalTasks = 10;
      const pendingTasks = totalTasks - queueSize;
      const expectedPercentDone = Math.round(100 * pendingTasks / totalTasks);
      const req = {} as Request;
      const res = {
        send: vi.fn(),
        status: vi.fn().mockReturnThis(),
      } as unknown as Response;

      vi.spyOn(this.queue, 'size').mockResolvedValue(queueSize);
      vi.spyOn(this.store, 'count').mockResolvedValue(totalTasks);

      // Act
      await this.getQueueStatus(req, res);

      // Assert
      expect(res.send).toHaveBeenCalledWith({ pending: queueSize, total: totalTasks, percentDone: expectedPercentDone });
      expect(res.status).not.toHaveBeenCalled();
    });

    // should handle error when getting queue size
    it('should handle error when getting queue size', async () => {
      // Arrange
      const req = {} as Request;
      const res = {
        send: vi.fn(),
        status: vi.fn().mockReturnThis(),
      } as unknown as Response;

      vi.spyOn(this.queue, 'size').mockRejectedValue(new Error());

      // Act
      await this.getQueueStatus(req, res);

      // Assert
      expect(res.send).not.toHaveBeenCalled();
      expect(res.status).toHaveBeenCalledWith(500);
    });

    // should calculate percentDone correctly
    it('should return queue status with correct percentDone when successful', async () => {
      // Arrange
      const queueSize = 5;
      const totalTasks = 10;
      const pendingTasks = totalTasks - queueSize;
      const expectedPercentDone = Math.round(100 * pendingTasks / totalTasks);
      const req = {} as Request;
      const res = {
        send: jest.fn(),
        status: jest.fn().mockReturnThis(),
      } as unknown as Response;

      jest.spyOn(this.queue, 'size').mockResolvedValue(queueSize);
      jest.spyOn(this.store, 'count').mockResolvedValue(totalTasks);

      // Act
      await this.getQueueStatus(req, res);

      // Assert
      expect(res.send).toHaveBeenCalledWith({ pending: queueSize, total: totalTasks, percentDone: expectedPercentDone });
      expect(res.status).not.toHaveBeenCalled();
    });

    // should handle successful request
    it('should handle successful request', async () => {
      // Arrange
      const queueSize = 5;
      const totalTasks = 10;
      const pendingTasks = totalTasks - queueSize;
      const expectedPercentDone = Math.round(100 * pendingTasks / totalTasks);
      const req = {} as Request;
      const res = {
        send: jest.fn(),
        status: jest.fn().mockReturnThis(),
      } as unknown as Response;

      jest.spyOn(this.queue, 'size').mockResolvedValue(queueSize);
      jest.spyOn(this.store, 'count').mockResolvedValue(totalTasks);

      // Act
      await this.getQueueStatus(req, res);

      // Assert
      expect(res.send).toHaveBeenCalledWith({ pending: queueSize, total: totalTasks, percentDone: expectedPercentDone });
      expect(res.status).not.toHaveBeenCalled();
    });

    // should handle empty queue and store
    it('should handle empty queue and store', async () => {
      // Arrange
      const queueSize = 0;
      const totalTasks = 0;
      const expectedPercentDone = 0;
      const req = {} as Request;
      const res = {
        send: jest.fn(),
        status: jest.fn().mockReturnThis(),
      } as unknown as Response;

      jest.spyOn(this.queue, 'size').mockResolvedValue(queueSize);
      jest.spyOn(this.store, 'count').mockResolvedValue(totalTasks);

      // Act
      await this.getQueueStatus(req, res);

      // Assert
      expect(res.send).toHaveBeenCalledWith({ pending: queueSize, total: totalTasks, percentDone: expectedPercentDone });
      expect(res.status).not.toHaveBeenCalled();
    });
});
